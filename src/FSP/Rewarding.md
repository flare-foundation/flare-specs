# Rewarding

## Overview

To incentivize participation in FSP, a reward mechanism exists that distributes funds to infrastructure providers and their delegators based performance in each sub-protocol.

The current sub-protocols are:
1) **Flare Time Series Oracle (FTSO)** - anchor feeds (project name "FTSO Scaling")
2) **Flare Time Series Oracle (FTSO)** - block latency feeds (project name "FTSO Fast Updates")
3) **Flare Data Connector (FDC)**

Rewards are distributed every 3.5 days, which constitutes a **reward epoch**. A combined reward amount is issued to a beneficiary for all sub-protocols for the whole reward epoch. 

Rewards are issued as **claims**, which beneficiaries need to submit to the [`RewardManager`](https://gitlab.com/flarenetwork/flare-smart-contracts-v2/-/blob/main/contracts/protocol/implementation/RewardManager.sol?ref_type=heads) smart contract to receive funds.

A complete list of claims is calculated after the reward epoch ends, and a combined **reward hash** is generated by using a Merkle Tree. Once the hash is signed by weight-based majority of the participants, reward claiming becomes available on `RewardManager`.

### Reward epoch

- Infrastructure providers must register as participants for every reward epoch. Only registered entities can submit votes in data protocols.
- Every reward epoch initializes a signing policy on start, with registered participants and their weights. Only those participants (and their delegators) will be rewarded, and reward amounts will be based on relative weights.

For more details on reward epochs, see [Epochs](Epochs.md).

### Voting rounds

FTSO and FDC protocols operate in sequential voting rounds, during which data is submitted and consensus reached on protocol outputs. 

Rewards are calculated for every round, and later aggregated for all rounds in the reward epoch for distribution.

### Incentives and penalties

Correct protocol participation results in accruing rewards, malicious behavior is disincentivized by applying reward **penalties**. Penalties are negative reward amounts per round, which accumulate and may potentially result in total negative reward amount for an entity for the full reward epoch. In that case, the entity receives no rewards.

### Minimal conditions

For FSP security, infrastructure providers are expected to participate in **all** subprotocols, as well as staking - operate a Flare validator node. A set minimal participation conditions is defined for each protocol that have to be met for an entity to receive rewards.

Once reward claims are calculated for an epoch, provider submissions are analyzed, and if participation thresholds are not met, the claims for the provider and their delegators might get burnt.

### Calculation overview

The reward calculation process consists of three main phases:

- [**Data retrieval and validation**](#data-retrieval-and-validation): Reward epoch metadata and submissions are loaded and decoded from transaction data provided by the [FSP C-Chain indexer](https://github.com/flare-foundation/flare-system-c-chain-indexer).

- [**Reward calculation**](#reward-calculation): Reward funds and submissions are allocated to voting rounds, with reward claims and penalties calculated for each round according to protocol-specific rules.

- [**Aggregation and finalization**](#aggregation-and-finalization): Reward claims are aggregated across all protocols, penalties and minimal participation conditions are applied, and a final set of claims is produced (one claim per beneficiary and type). A Merkle tree is constructed from these final claims to generate an epoch reward hash for signing.

Once the reward hash receives majority approval through signatures, providers can begin claiming their rewards.

## Data retrieval and validation

This phase involves gathering the necessary data for the reward calculation process, including available rewards, epoch metadata, and protocol submission messages from participants. All data is parsed from raw transactions and logs captured by the indexer.

### Reward sources

Rewards are sourced from inflation allocations and additional protocol-specific streams:

| Protocol Name                                         | Inflation Share | Additional Sources                        |
| ----------------------------------------------------- | --------------- | ----------------------------------------- |
| FTSO Scaling                                          | 24.5%           | Community feed reward offers submissions. |
| FTSO Fast Update                                      | 10.5%           | Volatility incentives.                    |
| FDC                                                   | 35%             | Attestation request fees.                 |
| *Validator Rewards (independent rewarding mechanism)* | *30%*           |                                           |

For each protocol, funds from available sources are pooled together and distributed [equally](../Utilities/IntOperations.md#integer-division-with-remainder-distribution) across all voting rounds within the reward epoch.

### Epoch metadata

The following smart contract events are processed to obtain epoch metadata:

| Event Name               | Contract                   | Query Range                                                                  | Description                                                                      |
| ------------------------ | -------------------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| SigningPolicyInitialized | Relay                      | $T \in [t_{\text{start}}(F_{e}) - D_{\text{init}}, t_{\text{start}}(F_{e}))$ | [SigningPolicy](SigningPolicy.md) for the epoch.                                 |
| VoterRegistered          | VoterRegistry              | $T \in [t_{\text{start}}(F_{e}) - D_{\text{init}}, t_{\text{start}}(F_{e}))$ | Voter addresses and weights.                                                     |
| VoterRegistrationInfo    | FlareSystemsCalculator     | $T \in [t_{\text{start}}(F_{e}) - D_{\text{init}}, t_{\text{start}}(F_{e}))$ | Voter addresses and weights.                                                     |
| RewardsOffered           | FtsoRewardOfferManager     | $T \in [t_{\text{start}}(F_{e-1}), t_{\text{start}}(F_{e}))$                 | Community feed reward offers for FTSO.                                           |
| InflationRewardsOffered  | FtsoRewardOfferManager     | $T \in [t_{\text{start}}(F_{e-1}), t_{\text{start}}(F_{e}))$                 | Inflation rewards allocation for FTSO Scaling, defines the default set of feeds. |
| InflationRewardsOffered  | FastUpdateIncentiveManager | $T \in [t_{\text{start}}(F_{e-1}), t_{\text{start}}(F_{e}))$                 | Inflation rewards allocation for FTSO Fast Updates.                              |
| IncentiveOffered         | FastUpdateIncentiveManager | $T \in [t_{\text{start}}(F_{e}), t_{\text{start}}(e+1))$                     | Volatility incentives for Fast Updates.                                          |
| InflationRewardsOffered  | FdcHub                     | $T \in [t_{\text{start}}(F_{e-1}), t_{\text{start}}(F_{e}))$                 | Inflation rewards allocation for FDC.                                            |

where:
- $T$: Transaction timestamp (Unix).
- $D_{\text{init}}$: Signing policy initialization duration.
- $t_{\text{start}}(r)$: Start time of round $r$. See [Voting Round](Epochs.md#voting-epoch).
- $F_{e}$: Start of the first round of reward epoch $e$, defined by the `SigningPolicyInitialized` event.

### Protocol submissions

For round-based protocols (FTSO Scaling, FDC) submissions are handled by the [Submission](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/protocol/implementation/Submission.sol#L14) smart contract, and finalizations get processed by [Relay](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/protocol/implementation/Relay.sol#L10).
See [Submission](Submission.md) and [Finalization](Finalization.md) pages for exact transaction references.

FTSO Fast Updates uses an independent mechanism via the [FastUpdater](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/fastUpdates/implementation/FastUpdater.sol) contract.


#### Submission transactions

The following transactions are processed for round-based protocol submissions:

| Method Call          | Contract   | Query Range                                                                   |
| -------------------- | ---------- | ----------------------------------------------------------------------------- |
| **submit1**          | Submission | $T \in [t_{\text{start}}(F_{e} - W_{b}), t_{\text{start}}(F_{e+1}+W_{s}))$    |
| **submit2**          | Submission | $T \in [t_{\text{start}}(F_{e}- W_{b}+1), t_{\text{start}}(F_{e+1}+W_{s}+1))$ |
| **submitSignatures** | Submission | $T \in [t_{\text{reveal}}(F_{e}+1)+1, t_{\text{start}}(F_{e+1}+1))$           |
| **relay**            | Relay      | $T \in [t_{\text{reveal}}(F_{e}+1)+1, t_{\text{start}}(F_{e+1}+1))$           |

where:
- $W_{b}$: System parameter `RandomGenerationBenchingWindow`.
- $W_{s}$: System parameter `FutureSecureRandomWindow`.


Submission transactions are included in reward computation only if they contain a valid protocol message and transaction timestamp.
The validation rules for submissions are defined as follows:

| Submission Type           | **Valid Timestamp Range**                               | Duplicate Handling                                                    | **Allowed Sender Address** |
| ------------------------- | ------------------------------------------------------- | --------------------------------------------------------------------- | -------------------------- |
| **Submit1**               | $T \in [t_{\text{start}}(R), t_{\text{start}}(R+1))$    | Last valid sender message used.                                       | **submit**                 |
| **Submit2**               | $T \in [t_{\text{start}}(R+1), t_{\text{reveal}}(R+1))$ | Last valid sender message used.                                       | **submit**                 |
| **SubmitSignatures**      | $T \in [t_{\text{reveal}}(R+1), t_{\text{start}}(R+2))$ | First valid sender message per hash used.                             | **submitSignatures**       |
| **Relay** (finalizations) | $T \in [t_{\text{reveal}}(R+1), t_{\text{start}}(R+2))$ | Only the first valid finalization per round per sender is considered. | Any                        |

where $R$ is the voting round id encoded in the submission.

Additional rules for finalizations:
- Encoded `SigningPolicy` must match the current reward epoch signing policy.
- `ProtocolMerkleRoot.RoundId`  must match the expected round:  $r = id_\text{round}(T) - 1$.
- Signatures sign the encoded `ProtocolMerkleRoot` hash.

Submissions not deemed valid at this stage are ignored and not used in reward and penalty computations.
Further validation steps are performed on sub-protocol level when extracting protocol-specific messages.

#### Fast Updates submissions

Fast Updates submission data is processed from the following events:

| Event Name               | Contract    | Query Range                                                      | Description                                       |
| ------------------------ | ----------- |------------------------------------------------------------------| ------------------------------------------------- |
| FastUpdateFeeds          | FastUpdater | $T \in [t_{\text{start}}(F_{e}+1), t_{\text{start}}(F_{e+1}+1))$ | Current feeds values for every round.             |
| FastUpdateFeedsSubmitted | FastUpdater | $T \in [t_{\text{start}}(F_{e}), t_{\text{start}}(F_{e+1}+1))$   | Confirmation of updates submission by a provider. |

# Reward calculation

This phase allocates funds and submission data to their corresponding voting rounds, and calculates individual reward claims and penalties according to protocol-specific rules.

For details on how rewards and penalties are calculated, see individual protocol descriptions:
- [FTSO Rewarding](../FTSO/Rewarding.md).
- [FDC Rewarding](../FDC/Rewarding.md).

### Reward claims

Every rewarded or penalized protocol action results in a **reward claim**, containing the following structure:

| Field       | Description                                                                                    |
| ----------- | ---------------------------------------------------------------------------------------------- |
| beneficiary | The address of the reward beneficiary or node ID (20-bytes).                                   |
| amount      | Amount of the reward in FLR.                                                                   |
| claimType   | Reward claim type (`0-3`), indicating its purpose and what type of address is the beneficiary. |


Supported reward claim types:
- **Direct** `(0)`: The beneficiary is any address. The reward is solely owed to the beneficiary. This type of claim is used for back claims of undistributed rewards for providers of funds into rewarding pools, burn claims, or other direct rewarding approaches needed in sub-protocols. 
- **Fee** `(1)`: The beneficiary is the identity address of an eligible entity for the reward epoch only (their address is provided). The fees include WFLR delegation fees and node staking fees. The reward is solely owed to the beneficiary.
- **Wflr** `(2)`: The beneficiary is the delegation address of an eligible entity for the given reward epoch. The amount includes the value to be distributed to the delegators according to their share in $W_D(beneficiary)$
- **Mirror** `(3)`: The beneficiary is a node ID of an eligible entity for the given reward epoch. The amount includes the value that is to be distributed to the stakers according to their share in the amount staked to the node ID.

# Aggregation and finalization

This phase aggregates reward claims across all protocols, applies penalties and minimal participation conditions, and produces the final set of claims with the epoch reward hash for signing.

## Minimal conditions ([FIP-10](https://proposals.flare.network/FIP/FIP_10.html))

To achieve Flare's mission as a Layer-1 enshrined-oracle network where all protocols operate under the same trust assumptions as the network, there is an incentive structure to ensure providers participate in all Flare protocols.

### Participation requirements

Each protocol will implement the minimum participation requirements, defined across each reward epoch independently.

#### FTSO anchor feeds
  - Providers must submit a value estimate that lies within a 0.5% band around the consensus median value in 80% of voting rounds within a reward epoch.

#### FTSO block-latency feeds
  - Providers must submit at least 80% of their expected number of updates within a reward epoch, unless they have very low weight, defined as < 0.2% of the total active weight.

#### FDC
  - Providers must be rewarded in 60% of voting rounds.

#### Staking
  - Providers must meet 80% total uptime in the reward epoch with at least 1M FLR in active self-bond. 
  - To earn passes, the provider must have at least 3M FLR in active self-bond and 15M in active stake. Providers with 80% total uptime and at least 1M FLR in active self-bond but not meeting both the 3M FLR active self-bond and 15M active stake requirements neither earn nor lose passes, and still receive eligible rewards.

Not meeting the requirements of even a single protocol will eventually lead to loss of rewards. 

### Passes

To protect against occasional underperformance, a **pass** system is implemented to act as a buffer mechanism:

- All providers start with **0 passes**.
  - If a provider held passes but missed the registration for an epoch, their pass count will also reset to 0 for the next registered epoch.
- A **pass** is awarded to a provider who meets **all minimum participation requirements** across all protocols during a reward epoch.
  - Number of held passes is capped at **3**.
- For each protocol a provider fails to meet the minimum requirement, they **lose 1 pass**.
  - If the resulting number of held passes falls **below 0**, the provider **loses all rewards** for that epoch. They will start the next epoch with **0 passes**, and are eligible for rewards if all conditions are met.

## Results

Once all reward claims and penalties are computed for all protocols, they are aggregated together and a combined reward hash is produced for signing.

### Aggregating claims

1. Reward claims from all protocols are merged together, resulting in a single claim for every beneficiary and claim type.
2. Separately, penalties from all protocols are merged together, resulting in a single penalty claim for every beneficiary and claim type.
3. Penalties are applied to reward claims. For each beneficiary and claim type, let $R$ be the total reward amount and $P$ the total penalty amount. The final reward $R_{\text{fin}}$ and the amount to be burnt $R_{\text{burn}}$ are computed as:

   $$
   R_{\text{fin}} = \max(R - P, 0)
   $$
   $$
   R_{\text{burn}} = \min(P, R)
   $$

   I.e. if the penalty amount is larger than the reward amount, the whole reward claim simply gets burnt. Otherwise, the reward claim amount gets adjusted to $R_{\text{fin}}$.

4. All resulting $R_{\text{burn}}$ amounts are combined and a single **Direct** type reward claim is produced with the burn address as the beneficiary.

### Applying minimal conditions

For every registered data provider, participation statistics are checked against the minimal conditions. If the resulting number of passes is below zero, all reward claims associated with that provider get burnt. This includes the following beneficiaries:
- Provider's `identityAddress` - fee rewards.
- Provider's `delegationAddress` - delegator rewards.
- All of provider's registered validator [node Ids](Voting-draft.md#node-id).

### Computing epoch reward hash

Each final reward claim is then abi-encoded and hashed as follows:

```Solidity
bytes32 claimHash = keccak256(
   abi.encode(
      rewardEpochId, beneficiary, amount, claimType
   )
)
```
where the claim is represented as:
```Solidity
struct RewardClaim {
   uint24 rewardEpochId;
   bytes20 beneficiary; 
   uint120 amount;
   ClaimType claimType;
}

enum ClaimType { DIRECT, FEE, WNAT, MIRROR, CCHAIN }
```

A combined epoch **reward hash** (`bytes32`) is then obtained by building a [MerkleTree](../Utilities/MerkleTree.md) from the list of individual claim hashes.

Each reward claim is the combined with the Merkle proof for its hash, producing a `RewardClaimWithProof` that can be used to claim reward funds via the `RewardManager` smart contract:

```Solidity
struct RewardClaimWithProof {
   bytes32[] merkleProof;
   RewardClaim body;
}
```

You can see an example reward claim distribution file for an epoch [here](https://github.com/flare-foundation/fsp-rewards/blob/main/flare/290/reward-distribution-data.json).

### Signing rewards

Each participant registered in the reward epoch needs to generate and submit a reward hash signature to the `FlareSystemsManager` contract:

```Solidity
function signRewards(
    uint24 _rewardEpochId,
    NumberOfWeightBasedClaims[] calldata _noOfWeightBasedClaims,
    bytes32 _rewardsHash,
    Signature calldata _signature
)

struct NumberOfWeightBasedClaims {
    uint256 rewardManagerId;
    uint256 noOfWeightBasedClaims;
}

struct Signature {
    uint8 v;
    bytes32 r;
    bytes32 s;
}
```

The `noOfWeightBasedClaims` parameter is the number of claims with `type > 1`, i.e. claims for community reward distribution.

A reward hash signature is generated using the [Signing](../Utilities/Signing.md) method.

Once the total weight of submitted signatures for the same hash reaches the signing policy threshold, rewards for the epoch can be claimed.